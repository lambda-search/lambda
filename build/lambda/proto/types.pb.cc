// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: lambda/proto/types.proto

#include "lambda/proto/types.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace lambda {
constexpr SnapshotRule::SnapshotRule(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : period_secs_(0)
  , changed_docs_(0){}
struct SnapshotRuleDefaultTypeInternal {
  constexpr SnapshotRuleDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SnapshotRuleDefaultTypeInternal() {}
  union {
    SnapshotRule _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SnapshotRuleDefaultTypeInternal _SnapshotRule_default_instance_;
constexpr IndexConf_FieldMetasEntry_DoNotUse::IndexConf_FieldMetasEntry_DoNotUse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct IndexConf_FieldMetasEntry_DoNotUseDefaultTypeInternal {
  constexpr IndexConf_FieldMetasEntry_DoNotUseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IndexConf_FieldMetasEntry_DoNotUseDefaultTypeInternal() {}
  union {
    IndexConf_FieldMetasEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IndexConf_FieldMetasEntry_DoNotUseDefaultTypeInternal _IndexConf_FieldMetasEntry_DoNotUse_default_instance_;
constexpr IndexConf_OptionsEntry_DoNotUse::IndexConf_OptionsEntry_DoNotUse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct IndexConf_OptionsEntry_DoNotUseDefaultTypeInternal {
  constexpr IndexConf_OptionsEntry_DoNotUseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IndexConf_OptionsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    IndexConf_OptionsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IndexConf_OptionsEntry_DoNotUseDefaultTypeInternal _IndexConf_OptionsEntry_DoNotUse_default_instance_;
constexpr IndexConf::IndexConf(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : snapshot_rules_()
  , field_metas_(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{})
  , options_(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{})
  , description_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , model_cksm_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , group_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , number_of_shards_(0)
  , number_of_replicas_(0)
  , dimension_(0)
  , metric_(0)

  , nprobe_(0)
  , direct_map_(false)
  , tmpfs4vector_(false)
  , model_size_(int64_t{0})
  , rebuild_rate_limiter_docs_per_sec_(int64_t{0})
  , memory_of_shards_(int64_t{0})
  , version_(int64_t{0})
  , engine_(0)

  , slowlog_log_slower_than_(1000){}
struct IndexConfDefaultTypeInternal {
  constexpr IndexConfDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IndexConfDefaultTypeInternal() {}
  union {
    IndexConf _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IndexConfDefaultTypeInternal _IndexConf_default_instance_;
constexpr FieldMeta::FieldMeta(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : field_type_(0)
{}
struct FieldMetaDefaultTypeInternal {
  constexpr FieldMetaDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~FieldMetaDefaultTypeInternal() {}
  union {
    FieldMeta _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT FieldMetaDefaultTypeInternal _FieldMeta_default_instance_;
constexpr IndexShardConf::IndexShardConf(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : nodes_()
  , index_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , conf_(nullptr)
  , shard_idx_(0){}
struct IndexShardConfDefaultTypeInternal {
  constexpr IndexShardConfDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IndexShardConfDefaultTypeInternal() {}
  union {
    IndexShardConf _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IndexShardConfDefaultTypeInternal _IndexShardConf_default_instance_;
}  // namespace lambda
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_lambda_2fproto_2ftypes_2eproto[6];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_lambda_2fproto_2ftypes_2eproto[3];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_lambda_2fproto_2ftypes_2eproto = nullptr;

const uint32_t TableStruct_lambda_2fproto_2ftypes_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::lambda::SnapshotRule, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::lambda::SnapshotRule, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::lambda::SnapshotRule, period_secs_),
  PROTOBUF_FIELD_OFFSET(::lambda::SnapshotRule, changed_docs_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::lambda::IndexConf_FieldMetasEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::lambda::IndexConf_FieldMetasEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::lambda::IndexConf_FieldMetasEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::lambda::IndexConf_FieldMetasEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::lambda::IndexConf_OptionsEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::lambda::IndexConf_OptionsEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::lambda::IndexConf_OptionsEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::lambda::IndexConf_OptionsEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::lambda::IndexConf, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::lambda::IndexConf, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::lambda::IndexConf, number_of_shards_),
  PROTOBUF_FIELD_OFFSET(::lambda::IndexConf, number_of_replicas_),
  PROTOBUF_FIELD_OFFSET(::lambda::IndexConf, description_),
  PROTOBUF_FIELD_OFFSET(::lambda::IndexConf, dimension_),
  PROTOBUF_FIELD_OFFSET(::lambda::IndexConf, metric_),
  PROTOBUF_FIELD_OFFSET(::lambda::IndexConf, nprobe_),
  PROTOBUF_FIELD_OFFSET(::lambda::IndexConf, snapshot_rules_),
  PROTOBUF_FIELD_OFFSET(::lambda::IndexConf, direct_map_),
  PROTOBUF_FIELD_OFFSET(::lambda::IndexConf, slowlog_log_slower_than_),
  PROTOBUF_FIELD_OFFSET(::lambda::IndexConf, engine_),
  PROTOBUF_FIELD_OFFSET(::lambda::IndexConf, tmpfs4vector_),
  PROTOBUF_FIELD_OFFSET(::lambda::IndexConf, model_size_),
  PROTOBUF_FIELD_OFFSET(::lambda::IndexConf, model_cksm_),
  PROTOBUF_FIELD_OFFSET(::lambda::IndexConf, rebuild_rate_limiter_docs_per_sec_),
  PROTOBUF_FIELD_OFFSET(::lambda::IndexConf, memory_of_shards_),
  PROTOBUF_FIELD_OFFSET(::lambda::IndexConf, group_),
  PROTOBUF_FIELD_OFFSET(::lambda::IndexConf, version_),
  PROTOBUF_FIELD_OFFSET(::lambda::IndexConf, field_metas_),
  PROTOBUF_FIELD_OFFSET(::lambda::IndexConf, options_),
  3,
  4,
  0,
  5,
  6,
  7,
  ~0u,
  8,
  15,
  14,
  9,
  10,
  1,
  11,
  12,
  2,
  13,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::lambda::FieldMeta, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::lambda::FieldMeta, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::lambda::FieldMeta, field_type_),
  0,
  PROTOBUF_FIELD_OFFSET(::lambda::IndexShardConf, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::lambda::IndexShardConf, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::lambda::IndexShardConf, index_),
  PROTOBUF_FIELD_OFFSET(::lambda::IndexShardConf, shard_idx_),
  PROTOBUF_FIELD_OFFSET(::lambda::IndexShardConf, conf_),
  PROTOBUF_FIELD_OFFSET(::lambda::IndexShardConf, nodes_),
  0,
  2,
  1,
  ~0u,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, -1, sizeof(::lambda::SnapshotRule)},
  { 10, 18, -1, sizeof(::lambda::IndexConf_FieldMetasEntry_DoNotUse)},
  { 20, 28, -1, sizeof(::lambda::IndexConf_OptionsEntry_DoNotUse)},
  { 30, 55, -1, sizeof(::lambda::IndexConf)},
  { 74, 81, -1, sizeof(::lambda::FieldMeta)},
  { 82, 92, -1, sizeof(::lambda::IndexShardConf)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::lambda::_SnapshotRule_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::lambda::_IndexConf_FieldMetasEntry_DoNotUse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::lambda::_IndexConf_OptionsEntry_DoNotUse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::lambda::_IndexConf_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::lambda::_FieldMeta_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::lambda::_IndexShardConf_default_instance_),
};

const char descriptor_table_protodef_lambda_2fproto_2ftypes_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\030lambda/proto/types.proto\022\006lambda\"9\n\014Sn"
  "apshotRule\022\023\n\013period_secs\030\001 \002(\005\022\024\n\014chang"
  "ed_docs\030\002 \002(\005\"\313\005\n\tIndexConf\022\030\n\020number_of"
  "_shards\030\001 \002(\005\022\032\n\022number_of_replicas\030\002 \002("
  "\005\022\023\n\013description\030\003 \002(\t\022\021\n\tdimension\030\004 \002("
  "\005\022\'\n\006metric\030\005 \002(\0162\027.lambda.IndexMetricTy"
  "pe\022\016\n\006nprobe\030\006 \001(\005\022,\n\016snapshot_rules\030\010 \003"
  "(\0132\024.lambda.SnapshotRule\022\022\n\ndirect_map\030\n"
  " \001(\010\022%\n\027slowlog_log_slower_than\030\013 \001(\005:\0041"
  "000\022<\n\006engine\030\014 \001(\0162\027.lambda.IndexEngine"
  "Type:\023ENGINE_FAISS_VECTOR\022\024\n\014tmpfs4vecto"
  "r\030\r \001(\010\022\022\n\nmodel_size\030\016 \001(\003\022\022\n\nmodel_cks"
  "m\030\017 \001(\t\022)\n!rebuild_rate_limiter_docs_per"
  "_sec\030\020 \001(\003\022\030\n\020memory_of_shards\030\021 \001(\003\022\r\n\005"
  "group\030\022 \001(\t\022\017\n\007version\030\023 \001(\003\0226\n\013field_me"
  "tas\030\024 \003(\0132!.lambda.IndexConf.FieldMetasE"
  "ntry\022/\n\007options\030\025 \003(\0132\036.lambda.IndexConf"
  ".OptionsEntry\032D\n\017FieldMetasEntry\022\013\n\003key\030"
  "\001 \001(\t\022 \n\005value\030\002 \001(\0132\021.lambda.FieldMeta:"
  "\0028\001\032.\n\014OptionsEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005valu"
  "e\030\002 \001(\t:\0028\001\"2\n\tFieldMeta\022%\n\nfield_type\030\001"
  " \001(\0162\021.lambda.FieldType\"b\n\016IndexShardCon"
  "f\022\r\n\005index\030\001 \002(\t\022\021\n\tshard_idx\030\002 \002(\005\022\037\n\004c"
  "onf\030\003 \002(\0132\021.lambda.IndexConf\022\r\n\005nodes\030\004 "
  "\003(\t*y\n\017IndexMetricType\022\036\n\032INDEX_METRIC_I"
  "NNER_PRODUCT\020\000\022\023\n\017INDEX_METRIC_L2\020\001\022\027\n\023I"
  "NDEX_METRIC_COSINE\020\002\022\030\n\024INDEX_METRIC_HAM"
  "MING\020\003*\230\001\n\017IndexEngineType\022\027\n\023ENGINE_FAI"
  "SS_VECTOR\020\000\022\027\n\023ENGINE_FAISS_BINARY\020\001\022\023\n\017"
  "ENGINE_FAISS_RT\020\002\022\022\n\016ENGINE_HNSWLIB\020\003\022\020\n"
  "\014ENGINE_KDISK\020\004\022\030\n\024ENGINE_FAISS_VIRTUAL\020"
  "\006*D\n\tFieldType\022\017\n\013TYPE_STRING\020\000\022\025\n\021TYPE_"
  "STRING_ARRAY\020\001\022\017\n\013TYPE_UINT64\020\002B\003\200\001\001"
  ;
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_lambda_2fproto_2ftypes_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_lambda_2fproto_2ftypes_2eproto = {
  false, false, 1316, descriptor_table_protodef_lambda_2fproto_2ftypes_2eproto, "lambda/proto/types.proto", 
  &descriptor_table_lambda_2fproto_2ftypes_2eproto_once, nullptr, 0, 6,
  schemas, file_default_instances, TableStruct_lambda_2fproto_2ftypes_2eproto::offsets,
  file_level_metadata_lambda_2fproto_2ftypes_2eproto, file_level_enum_descriptors_lambda_2fproto_2ftypes_2eproto, file_level_service_descriptors_lambda_2fproto_2ftypes_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_lambda_2fproto_2ftypes_2eproto_getter() {
  return &descriptor_table_lambda_2fproto_2ftypes_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_lambda_2fproto_2ftypes_2eproto(&descriptor_table_lambda_2fproto_2ftypes_2eproto);
namespace lambda {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IndexMetricType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_lambda_2fproto_2ftypes_2eproto);
  return file_level_enum_descriptors_lambda_2fproto_2ftypes_2eproto[0];
}
bool IndexMetricType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IndexEngineType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_lambda_2fproto_2ftypes_2eproto);
  return file_level_enum_descriptors_lambda_2fproto_2ftypes_2eproto[1];
}
bool IndexEngineType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 6:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FieldType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_lambda_2fproto_2ftypes_2eproto);
  return file_level_enum_descriptors_lambda_2fproto_2ftypes_2eproto[2];
}
bool FieldType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class SnapshotRule::_Internal {
 public:
  using HasBits = decltype(std::declval<SnapshotRule>()._has_bits_);
  static void set_has_period_secs(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_changed_docs(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

SnapshotRule::SnapshotRule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:lambda.SnapshotRule)
}
SnapshotRule::SnapshotRule(const SnapshotRule& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&period_secs_, &from.period_secs_,
    static_cast<size_t>(reinterpret_cast<char*>(&changed_docs_) -
    reinterpret_cast<char*>(&period_secs_)) + sizeof(changed_docs_));
  // @@protoc_insertion_point(copy_constructor:lambda.SnapshotRule)
}

inline void SnapshotRule::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&period_secs_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&changed_docs_) -
    reinterpret_cast<char*>(&period_secs_)) + sizeof(changed_docs_));
}

SnapshotRule::~SnapshotRule() {
  // @@protoc_insertion_point(destructor:lambda.SnapshotRule)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SnapshotRule::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SnapshotRule::ArenaDtor(void* object) {
  SnapshotRule* _this = reinterpret_cast< SnapshotRule* >(object);
  (void)_this;
}
void SnapshotRule::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SnapshotRule::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SnapshotRule::Clear() {
// @@protoc_insertion_point(message_clear_start:lambda.SnapshotRule)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&period_secs_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&changed_docs_) -
        reinterpret_cast<char*>(&period_secs_)) + sizeof(changed_docs_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SnapshotRule::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 period_secs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_period_secs(&has_bits);
          period_secs_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 changed_docs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_changed_docs(&has_bits);
          changed_docs_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SnapshotRule::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:lambda.SnapshotRule)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 period_secs = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_period_secs(), target);
  }

  // required int32 changed_docs = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_changed_docs(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:lambda.SnapshotRule)
  return target;
}

size_t SnapshotRule::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:lambda.SnapshotRule)
  size_t total_size = 0;

  if (_internal_has_period_secs()) {
    // required int32 period_secs = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_period_secs());
  }

  if (_internal_has_changed_docs()) {
    // required int32 changed_docs = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_changed_docs());
  }

  return total_size;
}
size_t SnapshotRule::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:lambda.SnapshotRule)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required int32 period_secs = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_period_secs());

    // required int32 changed_docs = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_changed_docs());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SnapshotRule::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SnapshotRule::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SnapshotRule::GetClassData() const { return &_class_data_; }

void SnapshotRule::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SnapshotRule *>(to)->MergeFrom(
      static_cast<const SnapshotRule &>(from));
}


void SnapshotRule::MergeFrom(const SnapshotRule& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:lambda.SnapshotRule)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      period_secs_ = from.period_secs_;
    }
    if (cached_has_bits & 0x00000002u) {
      changed_docs_ = from.changed_docs_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SnapshotRule::CopyFrom(const SnapshotRule& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:lambda.SnapshotRule)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SnapshotRule::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void SnapshotRule::InternalSwap(SnapshotRule* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SnapshotRule, changed_docs_)
      + sizeof(SnapshotRule::changed_docs_)
      - PROTOBUF_FIELD_OFFSET(SnapshotRule, period_secs_)>(
          reinterpret_cast<char*>(&period_secs_),
          reinterpret_cast<char*>(&other->period_secs_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SnapshotRule::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_lambda_2fproto_2ftypes_2eproto_getter, &descriptor_table_lambda_2fproto_2ftypes_2eproto_once,
      file_level_metadata_lambda_2fproto_2ftypes_2eproto[0]);
}

// ===================================================================

IndexConf_FieldMetasEntry_DoNotUse::IndexConf_FieldMetasEntry_DoNotUse() {}
IndexConf_FieldMetasEntry_DoNotUse::IndexConf_FieldMetasEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void IndexConf_FieldMetasEntry_DoNotUse::MergeFrom(const IndexConf_FieldMetasEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata IndexConf_FieldMetasEntry_DoNotUse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_lambda_2fproto_2ftypes_2eproto_getter, &descriptor_table_lambda_2fproto_2ftypes_2eproto_once,
      file_level_metadata_lambda_2fproto_2ftypes_2eproto[1]);
}

// ===================================================================

IndexConf_OptionsEntry_DoNotUse::IndexConf_OptionsEntry_DoNotUse() {}
IndexConf_OptionsEntry_DoNotUse::IndexConf_OptionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void IndexConf_OptionsEntry_DoNotUse::MergeFrom(const IndexConf_OptionsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata IndexConf_OptionsEntry_DoNotUse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_lambda_2fproto_2ftypes_2eproto_getter, &descriptor_table_lambda_2fproto_2ftypes_2eproto_once,
      file_level_metadata_lambda_2fproto_2ftypes_2eproto[2]);
}

// ===================================================================

class IndexConf::_Internal {
 public:
  using HasBits = decltype(std::declval<IndexConf>()._has_bits_);
  static void set_has_number_of_shards(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_number_of_replicas(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_description(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_dimension(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_metric(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_nprobe(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_direct_map(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_slowlog_log_slower_than(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_engine(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_tmpfs4vector(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_model_size(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_model_cksm(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_rebuild_rate_limiter_docs_per_sec(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_memory_of_shards(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_group(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000079) ^ 0x00000079) != 0;
  }
};

IndexConf::IndexConf(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  snapshot_rules_(arena),
  field_metas_(arena),
  options_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:lambda.IndexConf)
}
IndexConf::IndexConf(const IndexConf& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      snapshot_rules_(from.snapshot_rules_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  field_metas_.MergeFrom(from.field_metas_);
  options_.MergeFrom(from.options_);
  description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_description()) {
    description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_description(), 
      GetArenaForAllocation());
  }
  model_cksm_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    model_cksm_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_model_cksm()) {
    model_cksm_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_model_cksm(), 
      GetArenaForAllocation());
  }
  group_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    group_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_group()) {
    group_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_group(), 
      GetArenaForAllocation());
  }
  ::memcpy(&number_of_shards_, &from.number_of_shards_,
    static_cast<size_t>(reinterpret_cast<char*>(&slowlog_log_slower_than_) -
    reinterpret_cast<char*>(&number_of_shards_)) + sizeof(slowlog_log_slower_than_));
  // @@protoc_insertion_point(copy_constructor:lambda.IndexConf)
}

inline void IndexConf::SharedCtor() {
description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
model_cksm_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  model_cksm_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
group_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  group_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&number_of_shards_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&engine_) -
    reinterpret_cast<char*>(&number_of_shards_)) + sizeof(engine_));
slowlog_log_slower_than_ = 1000;
}

IndexConf::~IndexConf() {
  // @@protoc_insertion_point(destructor:lambda.IndexConf)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void IndexConf::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  description_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  model_cksm_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  group_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void IndexConf::ArenaDtor(void* object) {
  IndexConf* _this = reinterpret_cast< IndexConf* >(object);
  (void)_this;
  _this->field_metas_. ~MapField();
  _this->options_. ~MapField();
}
inline void IndexConf::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena) {
  if (arena != nullptr) {
    arena->OwnCustomDestructor(this, &IndexConf::ArenaDtor);
  }
}
void IndexConf::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IndexConf::Clear() {
// @@protoc_insertion_point(message_clear_start:lambda.IndexConf)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  snapshot_rules_.Clear();
  field_metas_.Clear();
  options_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      description_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      model_cksm_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      group_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&number_of_shards_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&nprobe_) -
        reinterpret_cast<char*>(&number_of_shards_)) + sizeof(nprobe_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&direct_map_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&engine_) -
        reinterpret_cast<char*>(&direct_map_)) + sizeof(engine_));
    slowlog_log_slower_than_ = 1000;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IndexConf::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 number_of_shards = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_number_of_shards(&has_bits);
          number_of_shards_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 number_of_replicas = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_number_of_replicas(&has_bits);
          number_of_replicas_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string description = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_description();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "lambda.IndexConf.description");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 dimension = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_dimension(&has_bits);
          dimension_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .lambda.IndexMetricType metric = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::lambda::IndexMetricType_IsValid(val))) {
            _internal_set_metric(static_cast<::lambda::IndexMetricType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int32 nprobe = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_nprobe(&has_bits);
          nprobe_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .lambda.SnapshotRule snapshot_rules = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_snapshot_rules(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool direct_map = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_direct_map(&has_bits);
          direct_map_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 slowlog_log_slower_than = 11 [default = 1000];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_slowlog_log_slower_than(&has_bits);
          slowlog_log_slower_than_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .lambda.IndexEngineType engine = 12 [default = ENGINE_FAISS_VECTOR];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::lambda::IndexEngineType_IsValid(val))) {
            _internal_set_engine(static_cast<::lambda::IndexEngineType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(12, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool tmpfs4vector = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_tmpfs4vector(&has_bits);
          tmpfs4vector_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 model_size = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_model_size(&has_bits);
          model_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string model_cksm = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          auto str = _internal_mutable_model_cksm();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "lambda.IndexConf.model_cksm");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 rebuild_rate_limiter_docs_per_sec = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_rebuild_rate_limiter_docs_per_sec(&has_bits);
          rebuild_rate_limiter_docs_per_sec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 memory_of_shards = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_memory_of_shards(&has_bits);
          memory_of_shards_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string group = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          auto str = _internal_mutable_group();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "lambda.IndexConf.group");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 version = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_version(&has_bits);
          version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, .lambda.FieldMeta> field_metas = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(&field_metas_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<162>(ptr));
        } else
          goto handle_unusual;
        continue;
      // map<string, string> options = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(&options_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<170>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IndexConf::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:lambda.IndexConf)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 number_of_shards = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_number_of_shards(), target);
  }

  // required int32 number_of_replicas = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_number_of_replicas(), target);
  }

  // required string description = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "lambda.IndexConf.description");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_description(), target);
  }

  // required int32 dimension = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_dimension(), target);
  }

  // required .lambda.IndexMetricType metric = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      5, this->_internal_metric(), target);
  }

  // optional int32 nprobe = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->_internal_nprobe(), target);
  }

  // repeated .lambda.SnapshotRule snapshot_rules = 8;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_snapshot_rules_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, this->_internal_snapshot_rules(i), target, stream);
  }

  // optional bool direct_map = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(10, this->_internal_direct_map(), target);
  }

  // optional int32 slowlog_log_slower_than = 11 [default = 1000];
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(11, this->_internal_slowlog_log_slower_than(), target);
  }

  // optional .lambda.IndexEngineType engine = 12 [default = ENGINE_FAISS_VECTOR];
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      12, this->_internal_engine(), target);
  }

  // optional bool tmpfs4vector = 13;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(13, this->_internal_tmpfs4vector(), target);
  }

  // optional int64 model_size = 14;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(14, this->_internal_model_size(), target);
  }

  // optional string model_cksm = 15;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_model_cksm().data(), static_cast<int>(this->_internal_model_cksm().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "lambda.IndexConf.model_cksm");
    target = stream->WriteStringMaybeAliased(
        15, this->_internal_model_cksm(), target);
  }

  // optional int64 rebuild_rate_limiter_docs_per_sec = 16;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(16, this->_internal_rebuild_rate_limiter_docs_per_sec(), target);
  }

  // optional int64 memory_of_shards = 17;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(17, this->_internal_memory_of_shards(), target);
  }

  // optional string group = 18;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_group().data(), static_cast<int>(this->_internal_group().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "lambda.IndexConf.group");
    target = stream->WriteStringMaybeAliased(
        18, this->_internal_group(), target);
  }

  // optional int64 version = 19;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(19, this->_internal_version(), target);
  }

  // map<string, .lambda.FieldMeta> field_metas = 20;
  if (!this->_internal_field_metas().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::lambda::FieldMeta >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        (void)p;
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
          "lambda.IndexConf.FieldMetasEntry.key");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_field_metas().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_field_metas().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::lambda::FieldMeta >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::lambda::FieldMeta >::const_iterator
          it = this->_internal_field_metas().begin();
          it != this->_internal_field_metas().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = IndexConf_FieldMetasEntry_DoNotUse::Funcs::InternalSerialize(20, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::lambda::FieldMeta >::const_iterator
          it = this->_internal_field_metas().begin();
          it != this->_internal_field_metas().end(); ++it) {
        target = IndexConf_FieldMetasEntry_DoNotUse::Funcs::InternalSerialize(20, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  // map<string, string> options = 21;
  if (!this->_internal_options().empty()) {
    typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::PROTOBUF_NAMESPACE_ID::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        (void)p;
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
          p->first.data(), static_cast<int>(p->first.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
          "lambda.IndexConf.OptionsEntry.key");
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
          p->second.data(), static_cast<int>(p->second.length()),
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
          "lambda.IndexConf.OptionsEntry.value");
      }
    };

    if (stream->IsSerializationDeterministic() &&
        this->_internal_options().size() > 1) {
      ::std::unique_ptr<SortItem[]> items(
          new SortItem[this->_internal_options().size()]);
      typedef ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::size_type size_type;
      size_type n = 0;
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
          it = this->_internal_options().begin();
          it != this->_internal_options().end(); ++it, ++n) {
        items[static_cast<ptrdiff_t>(n)] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[static_cast<ptrdiff_t>(n)], Less());
      for (size_type i = 0; i < n; i++) {
        target = IndexConf_OptionsEntry_DoNotUse::Funcs::InternalSerialize(21, items[static_cast<ptrdiff_t>(i)]->first, items[static_cast<ptrdiff_t>(i)]->second, target, stream);
        Utf8Check::Check(&(*items[static_cast<ptrdiff_t>(i)]));
      }
    } else {
      for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
          it = this->_internal_options().begin();
          it != this->_internal_options().end(); ++it) {
        target = IndexConf_OptionsEntry_DoNotUse::Funcs::InternalSerialize(21, it->first, it->second, target, stream);
        Utf8Check::Check(&(*it));
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:lambda.IndexConf)
  return target;
}

size_t IndexConf::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:lambda.IndexConf)
  size_t total_size = 0;

  if (_internal_has_description()) {
    // required string description = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  if (_internal_has_number_of_shards()) {
    // required int32 number_of_shards = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_number_of_shards());
  }

  if (_internal_has_number_of_replicas()) {
    // required int32 number_of_replicas = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_number_of_replicas());
  }

  if (_internal_has_dimension()) {
    // required int32 dimension = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_dimension());
  }

  if (_internal_has_metric()) {
    // required .lambda.IndexMetricType metric = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_metric());
  }

  return total_size;
}
size_t IndexConf::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:lambda.IndexConf)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000079) ^ 0x00000079) == 0) {  // All required fields are present.
    // required string description = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());

    // required int32 number_of_shards = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_number_of_shards());

    // required int32 number_of_replicas = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_number_of_replicas());

    // required int32 dimension = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_dimension());

    // required .lambda.IndexMetricType metric = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_metric());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .lambda.SnapshotRule snapshot_rules = 8;
  total_size += 1UL * this->_internal_snapshot_rules_size();
  for (const auto& msg : this->snapshot_rules_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // map<string, .lambda.FieldMeta> field_metas = 20;
  total_size += 2 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_field_metas_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::lambda::FieldMeta >::const_iterator
      it = this->_internal_field_metas().begin();
      it != this->_internal_field_metas().end(); ++it) {
    total_size += IndexConf_FieldMetasEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // map<string, string> options = 21;
  total_size += 2 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_options_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_options().begin();
      it != this->_internal_options().end(); ++it) {
    total_size += IndexConf_OptionsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional string model_cksm = 15;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_model_cksm());
    }

    // optional string group = 18;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_group());
    }

  }
  // optional int32 nprobe = 6;
  if (cached_has_bits & 0x00000080u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_nprobe());
  }

  if (cached_has_bits & 0x0000ff00u) {
    // optional bool direct_map = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool tmpfs4vector = 13;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional int64 model_size = 14;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_model_size());
    }

    // optional int64 rebuild_rate_limiter_docs_per_sec = 16;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_rebuild_rate_limiter_docs_per_sec());
    }

    // optional int64 memory_of_shards = 17;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_memory_of_shards());
    }

    // optional int64 version = 19;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_version());
    }

    // optional .lambda.IndexEngineType engine = 12 [default = ENGINE_FAISS_VECTOR];
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_engine());
    }

    // optional int32 slowlog_log_slower_than = 11 [default = 1000];
    if (cached_has_bits & 0x00008000u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_slowlog_log_slower_than());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IndexConf::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    IndexConf::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IndexConf::GetClassData() const { return &_class_data_; }

void IndexConf::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<IndexConf *>(to)->MergeFrom(
      static_cast<const IndexConf &>(from));
}


void IndexConf::MergeFrom(const IndexConf& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:lambda.IndexConf)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  snapshot_rules_.MergeFrom(from.snapshot_rules_);
  field_metas_.MergeFrom(from.field_metas_);
  options_.MergeFrom(from.options_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_description(from._internal_description());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_model_cksm(from._internal_model_cksm());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_group(from._internal_group());
    }
    if (cached_has_bits & 0x00000008u) {
      number_of_shards_ = from.number_of_shards_;
    }
    if (cached_has_bits & 0x00000010u) {
      number_of_replicas_ = from.number_of_replicas_;
    }
    if (cached_has_bits & 0x00000020u) {
      dimension_ = from.dimension_;
    }
    if (cached_has_bits & 0x00000040u) {
      metric_ = from.metric_;
    }
    if (cached_has_bits & 0x00000080u) {
      nprobe_ = from.nprobe_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      direct_map_ = from.direct_map_;
    }
    if (cached_has_bits & 0x00000200u) {
      tmpfs4vector_ = from.tmpfs4vector_;
    }
    if (cached_has_bits & 0x00000400u) {
      model_size_ = from.model_size_;
    }
    if (cached_has_bits & 0x00000800u) {
      rebuild_rate_limiter_docs_per_sec_ = from.rebuild_rate_limiter_docs_per_sec_;
    }
    if (cached_has_bits & 0x00001000u) {
      memory_of_shards_ = from.memory_of_shards_;
    }
    if (cached_has_bits & 0x00002000u) {
      version_ = from.version_;
    }
    if (cached_has_bits & 0x00004000u) {
      engine_ = from.engine_;
    }
    if (cached_has_bits & 0x00008000u) {
      slowlog_log_slower_than_ = from.slowlog_log_slower_than_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IndexConf::CopyFrom(const IndexConf& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:lambda.IndexConf)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IndexConf::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(snapshot_rules_))
    return false;
  return true;
}

void IndexConf::InternalSwap(IndexConf* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  snapshot_rules_.InternalSwap(&other->snapshot_rules_);
  field_metas_.InternalSwap(&other->field_metas_);
  options_.InternalSwap(&other->options_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &description_, lhs_arena,
      &other->description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &model_cksm_, lhs_arena,
      &other->model_cksm_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &group_, lhs_arena,
      &other->group_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IndexConf, engine_)
      + sizeof(IndexConf::engine_)
      - PROTOBUF_FIELD_OFFSET(IndexConf, number_of_shards_)>(
          reinterpret_cast<char*>(&number_of_shards_),
          reinterpret_cast<char*>(&other->number_of_shards_));
  swap(slowlog_log_slower_than_, other->slowlog_log_slower_than_);
}

::PROTOBUF_NAMESPACE_ID::Metadata IndexConf::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_lambda_2fproto_2ftypes_2eproto_getter, &descriptor_table_lambda_2fproto_2ftypes_2eproto_once,
      file_level_metadata_lambda_2fproto_2ftypes_2eproto[3]);
}

// ===================================================================

class FieldMeta::_Internal {
 public:
  using HasBits = decltype(std::declval<FieldMeta>()._has_bits_);
  static void set_has_field_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

FieldMeta::FieldMeta(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:lambda.FieldMeta)
}
FieldMeta::FieldMeta(const FieldMeta& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  field_type_ = from.field_type_;
  // @@protoc_insertion_point(copy_constructor:lambda.FieldMeta)
}

inline void FieldMeta::SharedCtor() {
field_type_ = 0;
}

FieldMeta::~FieldMeta() {
  // @@protoc_insertion_point(destructor:lambda.FieldMeta)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void FieldMeta::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FieldMeta::ArenaDtor(void* object) {
  FieldMeta* _this = reinterpret_cast< FieldMeta* >(object);
  (void)_this;
}
void FieldMeta::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FieldMeta::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FieldMeta::Clear() {
// @@protoc_insertion_point(message_clear_start:lambda.FieldMeta)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  field_type_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FieldMeta::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .lambda.FieldType field_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::lambda::FieldType_IsValid(val))) {
            _internal_set_field_type(static_cast<::lambda::FieldType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FieldMeta::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:lambda.FieldMeta)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .lambda.FieldType field_type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_field_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:lambda.FieldMeta)
  return target;
}

size_t FieldMeta::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:lambda.FieldMeta)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .lambda.FieldType field_type = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_field_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FieldMeta::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    FieldMeta::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FieldMeta::GetClassData() const { return &_class_data_; }

void FieldMeta::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<FieldMeta *>(to)->MergeFrom(
      static_cast<const FieldMeta &>(from));
}


void FieldMeta::MergeFrom(const FieldMeta& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:lambda.FieldMeta)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_field_type()) {
    _internal_set_field_type(from._internal_field_type());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FieldMeta::CopyFrom(const FieldMeta& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:lambda.FieldMeta)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FieldMeta::IsInitialized() const {
  return true;
}

void FieldMeta::InternalSwap(FieldMeta* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(field_type_, other->field_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FieldMeta::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_lambda_2fproto_2ftypes_2eproto_getter, &descriptor_table_lambda_2fproto_2ftypes_2eproto_once,
      file_level_metadata_lambda_2fproto_2ftypes_2eproto[4]);
}

// ===================================================================

class IndexShardConf::_Internal {
 public:
  using HasBits = decltype(std::declval<IndexShardConf>()._has_bits_);
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_shard_idx(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::lambda::IndexConf& conf(const IndexShardConf* msg);
  static void set_has_conf(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::lambda::IndexConf&
IndexShardConf::_Internal::conf(const IndexShardConf* msg) {
  return *msg->conf_;
}
IndexShardConf::IndexShardConf(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  nodes_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:lambda.IndexShardConf)
}
IndexShardConf::IndexShardConf(const IndexShardConf& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      nodes_(from.nodes_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  index_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    index_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_index()) {
    index_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_index(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_conf()) {
    conf_ = new ::lambda::IndexConf(*from.conf_);
  } else {
    conf_ = nullptr;
  }
  shard_idx_ = from.shard_idx_;
  // @@protoc_insertion_point(copy_constructor:lambda.IndexShardConf)
}

inline void IndexShardConf::SharedCtor() {
index_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  index_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&conf_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&shard_idx_) -
    reinterpret_cast<char*>(&conf_)) + sizeof(shard_idx_));
}

IndexShardConf::~IndexShardConf() {
  // @@protoc_insertion_point(destructor:lambda.IndexShardConf)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void IndexShardConf::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  index_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete conf_;
}

void IndexShardConf::ArenaDtor(void* object) {
  IndexShardConf* _this = reinterpret_cast< IndexShardConf* >(object);
  (void)_this;
}
void IndexShardConf::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IndexShardConf::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IndexShardConf::Clear() {
// @@protoc_insertion_point(message_clear_start:lambda.IndexShardConf)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  nodes_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      index_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(conf_ != nullptr);
      conf_->Clear();
    }
  }
  shard_idx_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IndexShardConf::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_index();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "lambda.IndexShardConf.index");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 shard_idx = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_shard_idx(&has_bits);
          shard_idx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .lambda.IndexConf conf = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_conf(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string nodes = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_nodes();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            #ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "lambda.IndexShardConf.nodes");
            #endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IndexShardConf::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:lambda.IndexShardConf)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string index = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_index().data(), static_cast<int>(this->_internal_index().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "lambda.IndexShardConf.index");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_index(), target);
  }

  // required int32 shard_idx = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_shard_idx(), target);
  }

  // required .lambda.IndexConf conf = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::conf(this), target, stream);
  }

  // repeated string nodes = 4;
  for (int i = 0, n = this->_internal_nodes_size(); i < n; i++) {
    const auto& s = this->_internal_nodes(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "lambda.IndexShardConf.nodes");
    target = stream->WriteString(4, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:lambda.IndexShardConf)
  return target;
}

size_t IndexShardConf::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:lambda.IndexShardConf)
  size_t total_size = 0;

  if (_internal_has_index()) {
    // required string index = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_index());
  }

  if (_internal_has_conf()) {
    // required .lambda.IndexConf conf = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *conf_);
  }

  if (_internal_has_shard_idx()) {
    // required int32 shard_idx = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_shard_idx());
  }

  return total_size;
}
size_t IndexShardConf::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:lambda.IndexShardConf)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string index = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_index());

    // required .lambda.IndexConf conf = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *conf_);

    // required int32 shard_idx = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_shard_idx());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string nodes = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(nodes_.size());
  for (int i = 0, n = nodes_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      nodes_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IndexShardConf::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    IndexShardConf::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IndexShardConf::GetClassData() const { return &_class_data_; }

void IndexShardConf::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<IndexShardConf *>(to)->MergeFrom(
      static_cast<const IndexShardConf &>(from));
}


void IndexShardConf::MergeFrom(const IndexShardConf& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:lambda.IndexShardConf)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  nodes_.MergeFrom(from.nodes_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_index(from._internal_index());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_conf()->::lambda::IndexConf::MergeFrom(from._internal_conf());
    }
    if (cached_has_bits & 0x00000004u) {
      shard_idx_ = from.shard_idx_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IndexShardConf::CopyFrom(const IndexShardConf& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:lambda.IndexShardConf)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IndexShardConf::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_conf()) {
    if (!conf_->IsInitialized()) return false;
  }
  return true;
}

void IndexShardConf::InternalSwap(IndexShardConf* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  nodes_.InternalSwap(&other->nodes_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &index_, lhs_arena,
      &other->index_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IndexShardConf, shard_idx_)
      + sizeof(IndexShardConf::shard_idx_)
      - PROTOBUF_FIELD_OFFSET(IndexShardConf, conf_)>(
          reinterpret_cast<char*>(&conf_),
          reinterpret_cast<char*>(&other->conf_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IndexShardConf::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_lambda_2fproto_2ftypes_2eproto_getter, &descriptor_table_lambda_2fproto_2ftypes_2eproto_once,
      file_level_metadata_lambda_2fproto_2ftypes_2eproto[5]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace lambda
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::lambda::SnapshotRule* Arena::CreateMaybeMessage< ::lambda::SnapshotRule >(Arena* arena) {
  return Arena::CreateMessageInternal< ::lambda::SnapshotRule >(arena);
}
template<> PROTOBUF_NOINLINE ::lambda::IndexConf_FieldMetasEntry_DoNotUse* Arena::CreateMaybeMessage< ::lambda::IndexConf_FieldMetasEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::lambda::IndexConf_FieldMetasEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::lambda::IndexConf_OptionsEntry_DoNotUse* Arena::CreateMaybeMessage< ::lambda::IndexConf_OptionsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::lambda::IndexConf_OptionsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::lambda::IndexConf* Arena::CreateMaybeMessage< ::lambda::IndexConf >(Arena* arena) {
  return Arena::CreateMessageInternal< ::lambda::IndexConf >(arena);
}
template<> PROTOBUF_NOINLINE ::lambda::FieldMeta* Arena::CreateMaybeMessage< ::lambda::FieldMeta >(Arena* arena) {
  return Arena::CreateMessageInternal< ::lambda::FieldMeta >(arena);
}
template<> PROTOBUF_NOINLINE ::lambda::IndexShardConf* Arena::CreateMaybeMessage< ::lambda::IndexShardConf >(Arena* arena) {
  return Arena::CreateMessageInternal< ::lambda::IndexShardConf >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
